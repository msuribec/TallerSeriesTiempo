---
title: "R Notebook"
output: html_notebook
---

```{r}
library(tseries)
library(forecast)
library(plotly)
library(dplyr)
library(readxl)
library(TSstudio)

```

# Simulación modelos

## Punto 1

```{r}
set.seed(1234)

k = 500  # Number of time series
n = 1000 # Time for each time serie

epsilon <- matrix(rnorm(k*n, mean = 0, sd = 1), nrow=k, ncol=n)
y1 <- matrix(, nrow=k, ncol=n)

for(i in 1:k){
  y1[i,1] <- 0
  y1[i,2] <- 0
}


for(i in 1:k){
  for(t in 3:n){ 
    y1[i,t] <- 0.5*y1[i,t-1] +y1[i,t-1] -0.5*y1[i,t-2] + epsilon[i,t] + 0.3* epsilon[i,t-1]
  }
}

par(mfrow=c(1,1))
matplot(t(y1), type = "l", xlab="Time", ylab="yt")
```

```{r}
adf.test(y1[1,])
adf.test(y1[10,])

# Phillips-Perron test
pp.test(y1[1,])
pp.test(y1[10,])

# KPSS test
kpss.test(y1[1,])
kpss.test(y1[10,])
```

```{r}
y1_diff <- matrix(, nrow=k, ncol=n-1)

for(i in 1:k){
  y1_diff[i,] <- diff(y1[i,]) 
}


adf.test(y1_diff[1,])
adf.test(y1_diff[10,])

# Phillips-Perron test
pp.test(y1_diff[1,])
pp.test(y1_diff[10,])

# KPSS test
kpss.test(y1_diff[1,])
kpss.test(y1_diff[10,])
```

```{r}
par(mfrow=c(2,2))
acf(y1_diff[2,])
acf(y1_diff[4,])
acf(y1_diff[8,])
acf(y1_diff[10,])


```

```{r}

par(mfrow=c(2,2))
pacf(y1_diff[2,])
pacf(y1_diff[4,])
pacf(y1_diff[8,])
pacf(y1_diff[10,])
```

```{r}

best_order2 <- c(0, 0, 0)
best_bic2 <- Inf
for (i in 0:5) for (j in 0:5) {
  fit_bic2 <- BIC(arima(y1_diff[1,], order = c(i, 0, j)))
  if (fit_bic2 < best_bic2) {
    best_order2 <- c(i, 0, j)
    best_bic2 <- fit_bic2
  }
}

```

```{r}
best_order2
best_bic2
```

```{r}


best_order2 <- c(0, 0, 0)
best_bic2 <- Inf
for (i in 0:5) for (j in 0:5)  {
  fit_bic2 <- BIC(arima(y1[1,], order = c(i, 1, j)))
  if (fit_bic2 < best_bic2) {
    best_order2 <- c(i, 1, j)
    best_bic2 <- fit_bic2
  }
}


```

```{r}
best_order2
best_bic2
```

```{r}
auto.arima(y1[1,])
```

## Punto 2

```{r}
set.seed(1234)
omega <- 0.06
alpha1 <- 0.2
beta1 <- 0.5
N <- 1000000
et <- rnorm(N,1,1)
rt <- rep(0, N)
sigmat <- rep(0, N)
for (i in 2:N) {
  sigmat[i] <- omega + alpha1 * (rt[i - 1]) + beta1 * sigmat[i-1]
  rt[i] <- et[i] * sqrt(sigmat[i])
}




```

```{r}
par(mfrow=c(1,1))
plot(rt, type = "l", xlab="Time", ylab="yt")
```

```{r}
par(mfrow=c(1,2))
acf(rt)
acf(rt^2)
```

```{r}
var(rt)
```

```{r}
omega/(1-alpha1-beta1)
```

```{r}
library(tseries)
rt.garch <- garch(rt, grad = "numerical", trace = FALSE)
confint(rt.garch)

```

## 

Punto 3

```{r}
set.seed(1234)
gamma <- 0.1
beta <- 0.2
N=1000
iid_normal_vars <- matrix(rnorm(2*N, mean = 0, sd = 1), nrow=2, ncol=N)
et <- iid_normal_vars[1,]
zeta <- iid_normal_vars[2,]
alphat <- rep(0, N)
yt <- rep(0, N)
for (i in 2:N) {
  alphat[i] <- gamma + beta * alphat[i - 1] + zeta[i]
  yt[i] <- alphat[i] * yt[i - 1] + et[i]
}
```

```{r}
par(mfrow=c(1,1))
plot(alphat, type = "l", xlab="Time", ylab="alphat")
```

```{r}
par(mfrow=c(1,1))
plot(yt, type = "l", xlab="Time", ylab="yt")
```

```{r}
par(mfrow=c(1,2))
acf(yt)
pacf(yt)
```

# Problema con datos de la economía colombiana

```{r}
setwd("C:/Users/sofia/Documents/2023-1/ST/Taller 2")
data <- read_excel("Data Assignment #2.xlsx", sheet=1)
t_desempleo <- ts(data$TD_NAL, start=c(2001, 1), end=c(2023, 3), frequency=12)
```

## Ajuste con datos completos

### 7. Gráfico de la serie de tiempo

```{r}
plot(t_desempleo, type = "l", xlab="Fecha", ylab="Tasa de desempleo")
```

### 8. Estadísticas

```{r}
summary(t_desempleo)
```

```{r}
data$Date[which.min(data$TD_NAL)]
data$Date[which.max(data$TD_NAL)]
```

### 9. Cuartiles y Kernel density plot

```{r}
quantile(t_desempleo, 0.25)
quantile(t_desempleo, 0.75)
```

```{r}
kd <- density(t_desempleo)

#create kernel density plot
plot(kd)

#fill in kernel density plot with specific color
polygon(kd, col='blue', border='black')
```

### 10. Pruebas estacionariedad

Prueba de Dickey-Fuller aumentada

```{r}
adf.test(t_desempleo)

```

Prueba Phillips-Perron

```{r}
pp.test(t_desempleo)

```

Prueba KPSS

```{r}
kpss.test(t_desempleo)
```

### 11. Ajuste a un ARIMA(3,1,3)

```{r}
arima(t_desempleo, order = c(3, 1, 3))
```

```{r}
t_desempleo_split <- ts_split(t_desempleo, sample.out = 12)
train <- t_desempleo_split$train
test <- t_desempleo_split$test
```

```{r}
par(mfrow=c(1,2))
acf(train, lag.max = 60)
pacf(train, lag.max = 60)
```

El decaimiento lineal de los rezagos estacionales indica que la serie no es estacionaria y que se requiere diferenciación estacional. Comenzaremos con una diferenciación estacional de la serie y la gráfica para identificar si la serie es estacionaria:

Primera diferencia estacional (12)

```{r}
t_desempleos_d12 <- diff(train, 12)
```

```{r}
par(mfrow=c(1,1))
plot(t_desempleos_d12, type="l", xlab="Fecha", ylab="%(first-difference)", main="Tasa de desempleo en Colombia -  Primera diferencia Estacional")
```

```{r}
adf.test(t_desempleos_d12)
```

```{r}
pp.test(t_desempleos_d12)
```

```{r}
kpss.test(t_desempleos_d12)
```

```{r}
p <- q <- P <- Q <- 0:2
p
 
```

```{r}

arima_grid <- expand.grid(p,q,P,Q)
names(arima_grid) <- c("p", "q", "P", "Q")
arima_grid$d <- 0
arima_grid$D <- 1
arima_grid
```

```{r}

arima_grid$k <- rowSums(arima_grid)
arima_grid 

```

```{r}
cases <- which(arima_grid$k <= 4)
length(cases)
```

```{r}
library(dplyr)
arima_grid_filter <- arima_grid %>% filter(k <= 4)
arima_grid_filter
```

```{r}
arima_search <- lapply(1:nrow(arima_grid_filter), function(i){
  md <- NULL
  md <- arima(train, order = c(arima_grid_filter$p[i], 0, arima_grid_filter$q[i]),
              seasonal = list(order = c(arima_grid_filter$P[i], 1, arima_grid_filter$Q[i])))
  results <- data.frame(p = arima_grid_filter$p[i], d = 0, q = arima_grid_filter$q[i],
                        P = arima_grid_filter$P[i], D = 1, Q = arima_grid_filter$Q[i],
                        AIC = md$aic)
  
#ARRANGE -> ORDENAR SEGÚN AIC
}) %>% bind_rows() %>% arrange(AIC)

arima_search
```

El mejor modelo es SARIMA(2,0,0)x(0,1,1)

```{r}
t_desempleos_best_md <- arima(train, order = c(2,0,0), seasonal = list(order = c(0,1,1)))
t_desempleos_best_md 
```

```{r}
t_desempleo_test_fc <- forecast(t_desempleos_best_md, h = 12)
t_desempleo_test_fc
```

```{r}
accuracy(t_desempleo_test_fc, test)
```

```{r}
test_forecast(t_desempleo, forecast.obj = t_desempleo_test_fc, test = test)
```

```{r}
final_md <- arima(t_desempleo, order = c(2,0,0), seasonal = list(order = c(0,1,1)))
final_md
```

```{r}
checkresiduals(final_md)
```

```{r}
t_desempleo_fc <- forecast(final_md, h = 12)
t_desempleo_fc # print forecasted values

```

```{r}
par(mfrow=c(1,1))
plot(t_desempleo_fc, main = "Tasa de desempleo - Forecast",  col.main = "darkgreen")

```

## Ajuste con datos antes de 2020

```{r}
t_desempleo_pre_covid <- window(t_desempleo, start = c(2001, 1), end = c(2020, 2)) 
```

```{r}

t_desempleo_split_pre_covid <- ts_split(t_desempleo_pre_covid, sample.out = 12)
train_precovid <- t_desempleo_split_pre_covid$train
test_precovid  <- t_desempleo_split_pre_covid$test
```

```{r}
par(mfrow=c(1,2))
acf(train_precovid, lag.max = 60)
pacf(train_precovid, lag.max = 60)
```

El decaimiento lineal de los rezagos estacionales indica que la serie no es estacionaria y que se requiere diferenciación estacional. Comenzaremos con una diferenciación estacional de la serie y la gráfica para identificar si la serie es estacionaria:

Primera diferencia estacional (12)

```{r}
t_desempleos_precovid_d12 <- diff(train_precovid, 12)
```

```{r}
par(mfrow=c(1,1))
plot(t_desempleos_precovid_d12 , type="l", xlab="Fecha", ylab="%(first-difference)", main="Tasa de desempleo en Colombia -  Primera diferencia Estacional")
```

```{r}
adf.test(t_desempleos_precovid_d12 )
```

```{r}
pp.test(t_desempleos_precovid_d12 )
```

```{r}
kpss.test(t_desempleos_precovid_d12 )
```

```{r}
p <- q <- P <- Q <- 0:2
p
 
```

```{r}

arima_grid <- expand.grid(p,q,P,Q)
names(arima_grid) <- c("p", "q", "P", "Q")
arima_grid$d <- 0
arima_grid$D <- 1
arima_grid
```

```{r}

arima_grid$k <- rowSums(arima_grid)
arima_grid 

```

```{r}
cases <- which(arima_grid$k <= 4)
length(cases)
```

```{r}
library(dplyr)
arima_grid_filter <- arima_grid %>% filter(k <= 4)
arima_grid_filter
```

```{r}
arima_search <- lapply(1:nrow(arima_grid_filter), function(i){
  md <- NULL
  md <- arima(train, order = c(arima_grid_filter$p[i], 0, arima_grid_filter$q[i]),
              seasonal = list(order = c(arima_grid_filter$P[i], 1, arima_grid_filter$Q[i])))
  results <- data.frame(p = arima_grid_filter$p[i], d = 0, q = arima_grid_filter$q[i],
                        P = arima_grid_filter$P[i], D = 1, Q = arima_grid_filter$Q[i],
                        AIC = md$aic)
  
#ARRANGE -> ORDENAR SEGÚN AIC
}) %>% bind_rows() %>% arrange(AIC)

arima_search
```

El mejor modelo es SARIMA(2,0,0)x(0,1,1)

```{r}
t_desempleos_best_md <- arima(train, order = c(2,0,0), seasonal = list(order = c(0,1,1)))
t_desempleos_best_md 
```

```{r}
t_desempleo_test_fc <- forecast(t_desempleos_best_md, h = 12)
t_desempleo_test_fc
```

```{r}
accuracy(t_desempleo_test_fc, test)
```

```{r}
test_forecast(t_desempleo, forecast.obj = t_desempleo_test_fc, test = test)
```

```{r}
final_md <- arima(t_desempleo, order = c(2,0,0), seasonal = list(order = c(0,1,1)))
final_md
```

```{r}
checkresiduals(final_md)
```

```{r}
t_desempleo_fc <- forecast(final_md, h = 12)
t_desempleo_fc # print forecasted values

```

```{r}
par(mfrow=c(1,1))
plot(t_desempleo_fc, main = "Tasa de desempleo - Forecast",  col.main = "darkgreen")

```
